<html>
  <head>
  <script>

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.download = factory();
  }
}(this, function () {

  return function download(data, strFileName, strMimeType) {

    var self = window, // this script is only for browsers anyway...
      defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads
      mimeType = strMimeType || defaultMime,
      payload = data,
      url = !strFileName && !strMimeType && payload,
      anchor = document.createElement("a"),
      toString = function(a){return String(a);},
      myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),
      fileName = strFileName || "download",
      blob,
      reader;
      myBlob= myBlob.call ? myBlob.bind(self) : Blob ;
    
    if(String(this)==="true"){ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
      payload=[payload, mimeType];
      mimeType=payload[0];
      payload=payload[1];
    }


    if(url && url.length< 2048){ // if no filename and no mime, assume a url was passed as the only argument
      fileName = url.split("/").pop().split("?")[0];
      anchor.href = url; // assign href prop to temp anchor
        if(anchor.href.indexOf(url) !== -1){ // if the browser determines that it's a potentially valid url path:
            var ajax=new XMLHttpRequest();
            ajax.open( "GET", url, true);
            ajax.responseType = 'blob';
            ajax.onload= function(e){ 
          download(e.target.response, fileName, defaultMime);
        };
            setTimeout(function(){ ajax.send();}, 0); // allows setting custom ajax headers using the return:
          return ajax;
      } // end if valid url?
    } // end if url?


    //go ahead and download dataURLs right away
    if(/^data\:[\w+\-]+\/[\w+\-]+[,;]/.test(payload)){
    
      if(payload.length > (1024*1024*1.999) && myBlob !== toString ){
        payload=dataUrlToBlob(payload);
        mimeType=payload.type || defaultMime;
      }else{      
        return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:
          navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :
          saver(payload) ; // everyone else can save dataURLs un-processed
      }
      
    }//end if dataURL passed?

    blob = payload instanceof myBlob ?
      payload :
      new myBlob([payload], {type: mimeType}) ;


    function dataUrlToBlob(strUrl) {
      var parts= strUrl.split(/[:;,]/),
      type= parts[1],
      decoder= parts[2] == "base64" ? atob : decodeURIComponent,
      binData= decoder( parts.pop() ),
      mx= binData.length,
      i= 0,
      uiArr= new Uint8Array(mx);

      for(i;i<mx;++i) uiArr[i]= binData.charCodeAt(i);

      return new myBlob([uiArr], {type: type});
     }

    function saver(url, winMode){

      if ('download' in anchor) { //html5 A[download]
        anchor.href = url;
        anchor.setAttribute("download", fileName);
        anchor.className = "download-js-link";
        anchor.innerHTML = "downloading...";
        anchor.style.display = "none";
        document.body.appendChild(anchor);
        setTimeout(function() {
          anchor.click();
          document.body.removeChild(anchor);
          if(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(anchor.href);}, 250 );}
        }, 66);
        return true;
      }

      // handle non-a[download] safari as best we can:
      if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
        url=url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
        if(!window.open(url)){ // popup blocked, offer direct download:
          if(confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")){ location.href=url; }
        }
        return true;
      }

      //do iframe dataURL download (old ch+FF):
      var f = document.createElement("iframe");
      document.body.appendChild(f);

      if(!winMode){ // force a mime that will download:
        url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
      }
      f.src=url;
      setTimeout(function(){ document.body.removeChild(f); }, 333);

    }//end saver




    if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
      return navigator.msSaveBlob(blob, fileName);
    }

    if(self.URL){ // simple fast and modern way using Blob and URL:
      saver(self.URL.createObjectURL(blob), true);
    }else{
      // handle non-Blob()+non-URL browsers:
      if(typeof blob === "string" || blob.constructor===toString ){
        try{
          return saver( "data:" +  mimeType   + ";base64,"  +  self.btoa(blob)  );
        }catch(y){
          return saver( "data:" +  mimeType   + "," + encodeURIComponent(blob)  );
        }
      }

      // Blob but not URL support:
      reader=new FileReader();
      reader.onload=function(e){
        saver(this.result);
      };
      reader.readAsDataURL(blob);
    }
    return true;
  }; /* end download() */
}));

function printCodes() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      document.getElementById("demo").innerHTML = this.responseText;
    }
  };
  var owner_id = document.getElementById('print_owner_id');
  var quantity = document.getElementById('print_quantity');
  xhttp.open("GET", "/downloadcodes/" + owner_id.value + "/" + quantity.value, false);
  xhttp.send();
}

function randomIntFromInterval(min,max)
{
    return Math.floor(Math.random()*(max-min+1)+min);
}

function generateCode(e) {

    var SETNUMBERS = 5000;
    var SETSIZE = 100;
    var CHARS = 10;

    var totalCount = 0;
    var totalSet = new Set([]);

    while ( totalCount < SETNUMBERS ) {
      var count = 0;
      var list = [];
      while (count < SETSIZE ) {
        var cod = "";
        var hasInSet = true;
        while ( hasInSet ) {
          cod = "";
          for ( var q = 0; q < CHARS+1; q++ ) {
              if ( q == CHARS/2 ) {
                cod += "-";
                continue;
              }
              if ( Math.random() > 0.5 ) {              
                  cod += String.fromCharCode( randomIntFromInterval(65,90) );
              } else {
                  cod += String.fromCharCode( randomIntFromInterval(48,57) );
              }
          }
          hasInSet = totalSet.has(cod);
          if ( !hasInSet ) {
            totalSet.add(cod);
          }
        }
        list[count] = {code : cod, downloaded : false, used: false, used_case: "", date_downloaded: -1, date_used: -1};
        count++;
      }
      var r = asyncCall(list);      
      timoutInc += 1000;
      totalCount++;
    }
        // ostrm << "{ \"code\" : \"" << code << "\", \"downloaded\" : false, \"used\" : false, \"use_case\" : \"\", \"date_downloaded\" : "
        //                                   "-1, \"date_used\" : -1 }";

  document.getElementById("codes").innerHTML = cod;        
}

  </script>
  </head>
  <body>
    <h3>Aryzon Codes</h3>
<!--     <div id="content">
    Codes Downloaded (Printed)
    </div>
    <hr>
 -->    <div id="codes"></div>
    <hr>
        Print Codes: 
        [owner] <input id="print_owner_id" type="text">
        [quantity] <input id="print_quantity" type="text">
        <input type="submit" onClick="printCodes()">
<!--    <hr>
         Generates Codes: 
        <input type="submit" onClick="generateCode()">
 -->    
    <hr>

<!--   <input type="file" id="file-input" />
  <h3>Contents of the file:</h3>  
  <pre id="file-content"></pre>

  <script>
  document.getElementById('file-input').addEventListener('change', readSingleFile, false);
  </script>
 -->
  </body>
</html>
